<!DOCTYPE html>
<html lang="ru">
<head>
    <title>React. Возможны побочные эффекты</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="shower/themes/material/styles/styles.css">
    <style>
        .shower {
            --slide-ratio: calc(16 / 9);
        }

        .b {
            display: block;
        }

        .c {
            color: var(--color-medium);
        }

        .slide pre {
            margin-top: 0;
        }

        .tiny-sample {
            display: inline-block;
            width: 0.8em;
            height: 0.8em;
            vertical-align: baseline;
        }

        .double {
            font-weight: 100;
            font-size: 48px;
            line-height: 1.5;
        }
    </style>
</head>
<body class="shower full">

<header class="caption">
    <h1>React. Возможны побочные эффекты</h1>
    <p>Владимир Кузнецов</p>
</header>

<section class="slide clear" id="title">
    <h2 class="shout">React. Возможны побочные эффекты</h2>
    <p>Владимир Кузнецов</p>
</section>

<section class="slide clear">
    <h2 class="shout">Типовая React-компонента</h2>
</section>

<section class="slide">
    <pre>
        <code>class Text extends React.Component {</code>
        <code>  render() {</code>
        <code>    return &lt;p>{this.props.text}&lt;/p></code>
        <code>  }</code>
        <code>}</code>
    </pre>
    <pre class="next">
        <code>const Text = ({ text }) => (</code>
        <code>  &lt;p>{text}&lt;/p></code>
        <code>);</code>
    </pre>
    <footer>
        Типовая React-компонента получает на вход набор параметров
        и возвращает описание DOM-элементов, которые вы хотите получить на экране.
    </footer>
</section>

<section class="slide">
    <h2>Результат зависит от</h2>
    <ul>
        <li>переданных <strong>props</strong>;</li>
        <li>внутреннего <strong>state</strong>;</li>
        <li>внешнего <strong>context</strong>.</li>
    </ul>
</section>

<section class="slide clear">
    <h2 class="shout">Побочный<br/>эффект</h2>
</section>

<section class="slide">
    <p style="font-size: 200%;">Побочный эффект &mdash; любые действия работающей программы, изменяющие среду выполнения.</p>
</section>

<section class="slide clear">
    <h2 class="shout">Управление побочными эффектами</h2>
</section>

<section class="slide">
    <h2>В методах жизненного цикла</h2>
    <pre>
        <code>class Text extends React.Component {</code>
        <code>  componentDidMount() { <span class="comment">/* добавили */</span> }</code>
        <code>  componentDidUpdate() { <span class="comment">/* обновили */</span> }</code>
        <code>  componentWillUnmount() { <span class="comment">/* удалили */</span> }</code>
        <code>  render() {</code>
        <code>    return &lt;p>{this.props.text}&lt;/p></code>
        <code>  }</code>
        <code>}</code>
    </pre>
</section>

<section class="slide">
    <h2>В хуках</h2>
    <pre>
        <code>const Text = ({ text }) => {</code>
        <code>  function createSideEffect() {</code>
        <code>    <span class="comment">/* добавили и обновили */</span></code>
        <code>  }</code>
        <code>  useEffect(createSideEffect);</code>
        <code>  return &lt;p>{text}&lt;/p></code>
        <code>};</code>
    </pre>
</section>

<section class="slide">
    <h2>В хуках</h2>
    <pre>
        <code>const Text = ({ text }) => {</code>
        <code>  function createSideEffect() {</code>
        <code>    <span class="comment">/* добавили и обновили text */</span></code>
        <code>    return () => { <span class="comment">/* удалили */</span> }</code>
        <code>  }</code>
        <code>  useEffect(createSideEffect, [text]);</code>
        <code>  return &lt;p>{text}&lt;/p></code>
        <code>};</code>
    </pre>
</section>

<section class="slide">
    <h2>В хуках</h2>
    <pre>
        <code>const Text = ({ text }) => {</code>
        <code>  function createSideEffect() {</code>
        <code>    <span class="comment">/* добавили */</span></code>
        <code>  }</code>
        <code>  useEffect(createSideEffect, []);</code>
        <code>  return &lt;p>{text}&lt;/p></code>
        <code>};</code>
    </pre>
</section>

<section class="slide">
    <h2>Что обычно делают</h2>
    <ul>
        <li>запускают асинхронные запросы;</li>
        <li class="next">вызывают action creator;</li>
        <li class="next">&hellip;</li>
    </ul>
</section>

<section class="slide">
    <h2>Что ещё можно делать</h2>
    <ul>
        <li>создавать дочерние DOM-элементы;</li>
        <li class="next">менять атрибуты у существующих DOM-элементов;</li>
        <li class="next">менять содержимое DOM-элементов вне дерева компонентов.</li>
    </ul>
</section>

<section class="slide clear">
    <h2 class="shout">Модуль<br/>react-side-effect</h2>
</section>

<section class="slide clear">
    <img src="img/react-side-effect.png" class="cover w h">
</section>

<section class="slide clear">
    <img src="img/react-document-title.png" class="cover w h">
</section>

<section class="slide clear black">
    <img src="img/all-clear.jpg" class="cover h">
</section>

<section class="slide clear">
    <h2 class="shout">Хуки!</h2>
</section>

<section class="slide">
    <a href="https://reactjs.org/docs/hooks-effect.html" target="_blank">
        <img src="img/using-effect-hook.png" class="cover h">
    </a>
</section>

<section class="slide">
    Как интегрироваться с другой библиотекой
    создание экземпляра класса
    использование синглетона
</section>

<section class="slide">
    React-компонента создает контейнер. Далее контейнер передается библиотеке. При перерисовке контейнер может
    измениться или удалиться. Библиотека должна уметь перерисовывать контент. Но, как правило, это не нужно, так как
    контейнер не меняется.
</section>

<section class="slide">
    Пример интеграции с видеоплеером. React создает контейнер, а VideoJS всё остальное.
</section>

<section class="slide">
    Когда состояние ну нужно синхронизировать, то кроме создания и удаления контента ничего не требуется. Синхронизация
    состояни всё усложняет, так как состояние в React-приложении может быть как локальным в компонентах, так и
    глобальным.
</section>

<section class="slide">
    Для синхронизации я рекомендую использовать только глобальное состояние через Redux, MobX, Storeon.
</section>

<section class="slide">
    Пример с Redux — карты. Синхронизация состояния происходит в middleware.
</section>

<section class="slide">
    Portals Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy
    of the parent component.
</section>

<section class="slide">
    React.createRef создает ссылку на DOM-элемент, который можно использовать как контейнер для сторонней библиотеки
</section>

<section class="slide" id="contacts">
    <h2>Владимир Кузнецов</h2>
    <p>
        <img alt="Twitter" src="img/twitter.svg" style="width: 24px; vertical-align: middle">
        <a href="https://twitter.com/mistakster" target="_blank">@mistakster</a> (English)<br>
        <img alt="Twitter" src="img/twitter.svg" style="width: 24px; vertical-align: middle">
        <a href="https://twitter.com/mista_k" target="_blank">@mista_k</a> (больше про жизнь)
    </p>
    <p>
        <img alt="Web-site" src="img/globe.svg" style="width: 24px; vertical-align: middle">
        <a href="https://noteskeeper.ru" target="_blank">noteskeeper.ru</a>
    </p>
    <p>
        Слайды презентации:
        <a href="https://bit.ly/uwdc19-rse">bit.ly/uwdc19-rse</a>
    </p>
</section>

<footer class="badge">
    <a href="https://github.com/shower/shower">Fork me on GitHub</a>
</footer>

<div class="progress"></div>

<script src="shower/shower.min.js"></script>
</body>
</html>
